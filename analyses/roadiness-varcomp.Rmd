---
title: 'Variance components'
author: "Jenna Krall"
date: "10/1/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, warning = F, message = F)
```

```{r}
# libraries
library(tidyverse)
library(gtools)

library(knitr)
library(here)
library(lme4)
library(broom.mixed)
library(performance)
library(ggthemes)
library(nlme)
library(forcats)
library(patchwork)
library(RColorBrewer)
# library(lmeInfo)

```


```{r}
# load data
load(here("data/rcomm2.RData"))


# load iqrs
load(here("data/iqrs.RData"))

# get functions for models
source(here("functions/model-funs.R"))

# load model results
load(here("results/main-res.RData"))


rcomm1 <- rcommLM

```



# Variance components

Using the methods described in Koehler et al. 2019

- Only highway has issues with random intercepts

```{r}
# model each microenv separately.  start with road type

# old
# eqn1 <- "lPM ~ rtype"
#   lme1 <- lme(formula(eqn1),
#               random= formula("~1 | ID / id3"),
#               data=rcomm1)

geticc <- function(dat) {
  lmer1 <- lmer(ilPM ~ (1| ID), data = dat)
  icc1 <- icc(lmer1)
  #browser()
  if(is.na(icc1[1])) {
    lme1 <- lme(ilPM ~ 1, random = ~1 | ID, data = dat)
    int1 <- intervals(lme1)
    with <- int1$reStruct$ID$est^2 
    #print("hi")
    res <- with/ (with + lme1$sigma^2)
  } else {
    res <- icc1$ICC_unadjusted
  }
  #c(icc1$ICC_unadjusted) # icc1$ICC_adjusted
  res
}

# note: summary same as mass-time-ratio
rcommU <- mutate(rcomm1, qsrness = quantcut(srness), qmph = quantcut(mph)) %>%
  dplyr::select(rtype, qsrness, qmph, ID, id3, PM) 

levrness <- levels(rcommU$qsrness)
levqmph <- levels(rcommU$qmph)
levrtype <- levels(rcommU$rtype)[rev(c(2, 4, 3, 1))]
qs <- paste0("Q", seq(1, 4))

icc <- rcommU %>%
  mutate(qsrness = factor(qsrness, levels = levrness, labels = qs),
         qmph = factor(qmph, levels = levqmph, labels = qs),
         rtype = factor(rtype, levels = levrtype)) %>%
  pivot_longer(rtype : qmph) %>%
  group_by(name, value, ID, id3) %>%
  summarize(ilPM = log(sum(PM))) %>%
  ungroup() %>%
  nest(data = c(ilPM, ID, id3)) %>%
  mutate(icc = purrr::map(data, ~geticc(dat = .))) %>%
  unnest(icc) %>%
  dplyr::select(-data) %>%
  mutate(name =    case_when(name == "qmph" ~ "Speed (mph)",
                          name == "qsrness" ~ "Roadiness",
                          name == "rtype" ~ "Road type")) %>%
  rename(`Road feature` = name, Value = value, ICC = icc)

save(icc, file = here("results/icc.RData"))
kable(icc, digits = 2)

# check
# lme1 <- lme(ilPM ~ 1, random = ~1 | ID, data = rcommU$data[[2]])
# int1 <- intervals(lme1)
#  with <- int1$reStruct$ID$est^2 
#  with/ (with + lme1$sigma^2)
# # 
# lmer1 <- lmer(ilPM ~ (1| ID), data = rcommU$data[[2]])
# icc(lmer1)
```








# Variance components: FYI





```{r}
lme1 <- resA$lme1
```


LME components

- sigma: the estimated within-group error standard deviation: `r lme1$sigma`
- AR correlation: `r lme1$modelStruct$corStruct`
- Components of variability:

```{r}

ggplot(resA$re, aes(x = est, y = name)) + 
  geom_pointrange(aes(xmin = lower, xmax = upper )) +
  xlab("Estimate") + ylab("")

```


## ICC

```{r, eval = F}
# ID, id3, rand
# btw vs. within
# id vs all
REs <- resA$re$est
names(REs) <- resA$re$name
REs["ID"]^2 / (sum(REs^2))
REs["id3"]^2 / (REs["id3"]^2+ REs["sigma"]^2)
sum(REs^2)
performance::icc(resA$lme1)

resA$re$est[1]^2 / (resA$re$est[1]^2  + resA$re$est[2]^2 )
resA$re$est[1]^2  / (resA$re$est[1]^2  + resA$re$est[3]^2 )
lme1$sigma 
# sig2bt  /  (sig2bt + sig2wi)
# sig2bt is random intercept var (between person)
# sig2wi is random var (within person)
```

## Documentation
```{r, eval =F}

#
# scale to 1
# > print(lme1$modelStruct$reStruct)
# Random effects:
#  Formula: ~1 | ID
#         (Intercept)
# StdDev:    1.323336 (DIVIDED BY RESIDUAL)
# 
#  Formula: ~1 | id3 %in% ID
#         (Intercept) Residual
# StdDev:    1.588816        1


# unconstrained: 	
# a logical value. If TRUE the coefficients are returned in unconstrained form (the same used in the optimization algorithm). If FALSE the coefficients are returned in "natural", possibly constrained, form. Defaults to TRUE.


# in unconstrained form (the same used in the optimization algorithm).
#  >  coef(lme1$modelStruct, unconstrained = T)
# reStruct.id3  reStruct.ID    corStruct 
unc <- c(  0.4629889,    0.2801560  ,  0.2113650 )


unc[1] / unc[2]
#  cor
unc1 <- unc[3]
 aux <- exp(unc[3])
(aux - 1) / (aux + 1)


# coefficients are returned in "natural", possibly constrained, form.
 # > coef(lme1$modelStruct, unconstrained = F)
 # reStruct.id3.var((Intercept))  reStruct.ID.var((Intercept))                 corStruct.Phi 
 #                    2.5243354                     1.7512190                     0.1052908 
 # 
scales <- sqrt(c(   2.5243354        ,             1.7512190  ))
scales
scales[c(1, 2)] * lme1$sigma

print(lme1)

# Random effects:
#  Formula: ~1 | ID
#         (Intercept)
# StdDev:   0.5211989
# 
#  Formula: ~1 | id3 %in% ID
#         (Intercept)  Residual
# StdDev:   0.6257585 0.3938522
```



```{r, eval = F}
# lme1$apVar # vcov of variance comp

# an object inheriting from class lmeStruct, representing a list of mixed-effects model components, such as reStruct, corStruct, and varFunc objects.


# other misc:
# cs1 <- corARMA(form = ~ 1|ID/group, p = 5, q = 5)
# resid <- resid(lme1, type = "normalized")
# VarCorr(lme1d)


# # basically 0
# lme2$coef$random$date_local %>% sd()
# lme3$coef$random$group %>% sd()

# 
# lme1$coef$random$id3 %>% sd()
# lme1$coef$random$ID %>% sd()
```         




    


